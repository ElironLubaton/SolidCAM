# -*- coding: utf-8 -*-
"""Data Process and Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ylIEYamP1hhI0T5AmausNglMW4x_83TH

# Data Processing

This notebook's **purpose** is processing the JSON files of parts in order to assign jobs to their relevant recognized hole group in the relevant topology.  
This notebook is used under the assumption that the JSON file is valid, where validation can be checked in the notebook 'JSON Validation'.

The data is being processed as follows:  
*   Iterating on the each part's jobs.

*   Dividing the jobs to either drilling jobs or non-drilling jobs.  

*   Creating a dictionary that holds all the topologies.

*   Assigning holes groups to their topology.  

*   Assigning jobs by the order they have been performed to their hole group.
"""

# @title Importing Libraries

import json
import numpy as np
import os
import matplotlib.pyplot as plt
import re

from enum import Enum

# @title Specify working directory path

# # Mount Google Drive
# from google.colab import drive
# drive.mount('/content/drive')

# Directory path to the JSON files
dir_path = '/content/test' # Modify it to your path

"""## Utilities and Helper Functions"""

# @title Reading JSON files

def read_json(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
    return data

# @title Code Cosmetics

def process_job_name(job_type):
  if   job_type == "NC_DRILL_OLD":       return "2_5D_Drilling"
  elif job_type == "NC_PROFILE":         return "Profile"
  elif job_type == "NC_DRILL_DEEP":      return "Multi_Depth_Drilling"
  elif job_type == "NC_THREAD":          return "Thread_Milling"
  elif job_type == "NC_DRILL_HR":        return "Drill_Recognition"
  elif job_type == "NC_JOB_MW_DRILL_5X": return "Multi Axis Drilling"
  else:                                  return job_type


def process_tool_type_name(tool_type):
  """ This function's purpose is for cosmetics - deletes prefix, and lowercases """
  # split the string by underscores
  words = tool_type.split('_')
  # remove prefix, and capitalize the first letter of each word and lowercase the rest
  processed_words = [word.capitalize() for word in words[1:]]
  # Join the words back with underscores
  return '_'.join(processed_words)


def topology_sort(topology_type):
  # Checking if the topology type is a valid string
  if len(topology_type)==0:
    return False
  else:
    # Cosmetics - using [5:] in order to remove 'HR_hw' prefix
    topology_type = topology_type[5:]

    # Cosmetics - adding underscores between capital letters
    return re.sub(r'(?<!^)(?=[A-Z])', '_', topology_type)


class Mask(Enum):
  """
  This class is used to deal with JSON's field '_geomShapeMask' - this field
  holds a vector of numbers that defines the topology of a hole, but not the
  hole's dimensions. The humber are written Right to Left (as in Hebrew).
  Each number in the mask tells us the shape of the segments composing the hole.
  """

  PLANE = 1
  CYLINDER = 2
  CONIC = 3
  CHAMFER = 4

  # I can access the strings by using: "Mask(number 1-4).name"

# @title Converting inch to mm

# """
# This cell will be used only once we're sure we know which fields we should
# convert from inch to mm.
# """

# def inches_to_mm(inches):
#   """ Converts inches to millimeters """
#   return round(inches*25.4, 3)

# def convert_json_units(data, exclude_fields=None):
#   """ Converting entire JSON file units from inch to mm """
#   # fields I want to exclude for various reasons
#   exclude_fields = ["coolant", "cycle", "ver", "usage_index", "home_number",
#                     "home_MAC", "home_position", "home_vParallelHomeNumbers",
#                     "job_feed", "job_holeWzrd_id", "job_spin", "max_power",
#                     "max_spin", "tool", "home_matrix"]

#   # Recursively process dictionaries
#   if isinstance(data, dict):
#     converted_data = {}
#     for key, value in data.items():
#       if key in exclude_fields:
#         # Keep the field as is if it's in the exclude list
#         converted_data[key] = value
#       elif key == "lengthParameters" and isinstance(value, list):
#         # Special handling for "lengthParameters"
#         converted_data[key] = [
#                   {**param,
#                     "value": inches_to_mm(param["value"]) if param.get("unit") == "inch" else param["value"],
#                     "unit": "mm" if param.get("unit") == "inch" else param.get("unit")}
#                   for param in value]
#       else:
#         # Recursively handle the value
#         converted_data[key] = convert_json_units(value, exclude_fields)
#     return converted_data

#   # Recursively process lists
#   elif isinstance(data, list):
#    return [convert_json_units(item) for item in data]
#   # Convert numeric values (excluding strings and booleans)
#   elif isinstance(data, (int, float)) and not isinstance(data, bool):
#     return inches_to_mm(data)
#   # Return the value as is for strings, booleans, or other types
#   return data

"""## Classes and Conversions"""

# @title Dealing with different MACs

def transform_points(coordinates, rotation_mat, translation_vec):
  """
  This function transforms hole center (x,y,z) coordinates from any coordinate
  system to the CAD model coordinate system:
  1 - Translation - Subtracting the translation vector from the hole center coordinates.
  2 - Rotation -    Dot product of the rotation matrix with the hole center coordinates.

  Args:
    coordinates:     Set with tuples of (x,y,z) centers of holes.
    rotation_mat:    3x3 np array of the Rotation Matrix.
    translation_vec: 3x1 np array of the Translation Vector.

  Returns:
    A set of the transformed points to the CAD model coordinate system
  """
  transformed_coordinates = set()

  for point in coordinates:
    # Convert the point to a numpy array (x, y, z)
    point_array = np.array([[point[0]], [point[1]], [point[2]]]).reshape(3,1)

    # Applying translation
    transformed_point = point_array - translation_vec
    # Applying rotation
    transformed_point = np.dot(rotation_mat, transformed_point)

    # Convert the transformed point to a tuple, round it, and add it to the set
    transformed_coordinates.add((round(transformed_point[0, 0], 3),
                                 round(transformed_point[1, 0], 3),
                                 round(transformed_point[2, 0], 3)))
  return transformed_coordinates


def rotation_translation(home_matrix):
  """
  This function extracts the Rotation Matrix and the Translation Vector from
  the home_matrix in the JSON.
  Both of them were computed with regards to the CAD coordinate system origin.

  *Notes:
    1 - We transpose the rotation matrix we got from home_matrix.
    2 - We disregard the last 4 elements in home_matrix.

  Args:
    home_matrix: A 16x1 list that contains the values of rotation and translation.

  Returns two elements:
    Rotation matrix -    3x3 numpy array.
    Translation vector - 3x1 numpy array.
  """
  # Extracting the rotation matrix values
  R_x = np.array(home_matrix[0:3])
  R_y = np.array(home_matrix[4:7])
  R_z = np.array(home_matrix[8:11])
  rotation_mat = np.array([R_x, R_y, R_z]).T

  # # Used if we want to convert from inch to mm
  # # Computing translation vector by refer to CAD model origin
  # if is_inch:  # converting to mm if needed
  #   translation_vec = np.array([inches_to_mm(home_matrix[3]),
  #                               inches_to_mm(home_matrix[7]),
  #                               inches_to_mm(home_matrix[11])]).reshape(3,1)
  # else:
  #   translation_vec = np.array([home_matrix[3], home_matrix[7], home_matrix[11]]).reshape(3,1)

  # Extracting the translation vector values
  translation_vec = np.array([home_matrix[3], home_matrix[7], home_matrix[11]]).reshape(3,1)

  return rotation_mat, translation_vec


def compare_coordinates(new_center, existing_centers, hole_depth, home_number, parallel_home_numbers):
  """
  This function compares (x,y,z) points in order to discern if two hole centers
  refer to the SAME hole by using the following conditions:
  1 - If the two holes centers (x,y,z) coordinates are the same.
  2 - If the distance between the two holes centers equals the hole's depth.

  *Note - This function is used in order to deal with cases where a hole is being worked
   different MACs (which are parallel).

  Args:
    new_point: Tuple containing the center we're checking.
    existing_centers: Set containing the hole's group exisiting centers.
    hole_depth: Int containing the hole's depth
    home_number: Int containing the new job's home number
    parallel_home_numbers: List containing the existing job parallel home numbers

  Returns:
    True if the two hole centers refer to DIFFERENT holes.
    False if the two hole centers refer to the SAME hole.
  """
  # 1 - Checking if the exact same coordinates already exist
  if new_center in existing_centers:
    return False

  # Going over on all the existing points in the hole group
  for existing_center in existing_centers:
    # Checking if the home numbers are parallel
    if home_number in parallel_home_numbers:
      # Checking if the distance between the centers equals the hole's depth
      centers_distance = np.linalg.norm(np.array(new_center) - np.array(existing_center))
      # If true, the two centers refer to the same hole, so return False
      if abs(centers_distance - hole_depth) <= tolerance:
        return False

  return True


def compare_geometries(new_geometry, existing_geometry):
  """
  This function compares the shape of two geometries ("_geom_ShapePoly" field).
  We make a straight-forward comparison, and if that doesn't work we compare
  the REVERSE of the geometry.

  *Note - This function is used in order to deal with cases where a hole
  is being worked from different MACs (which are parallel).

  The Algorithm:
  1 - Straight-forward comparison.
  2 - If True, then geometry already exist.
  3 - If False, Check if both geometries contain the same number of elements:
      - If False - the geometries are NOT the same, so return False.
      - If True  - then proceed to check if they are the same.
  4 - REVERSE the order of the elements in the geometry list we're checking
  5 - Check both lists with elements "head to head":
    5.1 - Compare the types of the elements
    5.2 - Compare the diameter of the elements
    5.3 - Compare the depth of the elements
  6 - If we passed 5, then geometry already exists

  Args:
    new_geometry: List of dictionaries containing the hole's description of the geometry we check
    new_geometry: List of dictionaries containing the hole's description of an existing geometry we compare to

  Returns:
    True  if the new geomtry and existing geometry are the same
    False if the new geomtry and existing geometry are NOT the same
  """

  # 1,2 - Straight-forwared comparison. If true, then geometry already exists.
  if new_geometry == existing_geometry:
    return True

  # 3 - Checking if both lists contain the same number of elements
  # If true, that proceed to check if they are the same, else, the geometries are NOT the same, so return False
  if len(new_geometry) != len(existing_geometry):
    return False

  # 4 - Reversing the order of the elements in the new_geometry
  # We do this in order to check if its the same geometry represented from parallel home MACs
  new_geometry.reverse()

  # 5 - Going over the elements "Head to Head" (from hebrew...)
  for i in range(len(new_geometry)):
    # 5.1 - If the types are different, the geometries are NOT the same
    if new_geometry[i]["type"] != existing_geometry[i]["type"]:
      return False
    else:
      # 5.2 - Checking if the diameters are the same. If not, then geometries are NOT the same
      if new_geometry[i]["p0"][0] != existing_geometry[i]["p1"][0]:
        return False

      # 5.3 - Checking if the depths are the same. If not, then geometries are NOT the same
      new_geom_depth = abs(new_geometry[i]["p0"][1] - new_geometry[i]["p1"][1])
      existing_geom_depth = abs(existing_geometry[i]["p0"][1] - existing_geometry[i]["p1"][1])
      if new_geom_depth != existing_geom_depth:
        return False

  # If we got here, then geometries are the same
  return True

# @title Defining Relevant Classes - Topology, Hole group, Job

class Topology:
  """ An object of this class holds all the holes in the specified topology """
  def __init__(self, topology):#, topology_mask):
    self.topology = topology           # String containing topology's name (e.g, CounterBore)
    # self.topology_mask = topology_mask # Int containing topology's mask
    self.holes_groups = []             # The hole groups that belong to this topology
    self.jobs_orders_dict = dict()     # Used for printing the legend in plots

  def add_hole_group(self, job, new_coordinates, new_geom_shape):
    """
    This method creates a new hole group to the relevant topology ONLY if the
    geometric shape of the hole group is new.
    If the geometric shape is not new, we just update the number of the instances
    in the hole group.
    """
    # Checking if the geometry shape already exists, and add if not
    for group in self.holes_groups:
      # if true, then geometry shape or its reverse already exists, so just updating number of centers
      if compare_geometries(new_geom_shape, group.geom_shape):
        # Going over the centers in the new coordinates in order to update centers
        for new_center in new_coordinates:
          # Going over all the jobs inside the hole group
          for existing_job in group.jobs:
            # Checking if the centers refer to the same hole
            if compare_coordinates(new_center, existing_job.centers, group.hole_depth,
                              job["home_number"], existing_job.parallel_home_numbers):
              group.centers.add(new_center)
        return group, False

    # The geometry shape doesn't exist, so we create a new group and add it
    new_group = HoleGroup(new_coordinates, new_geom_shape)
    self.holes_groups.append(new_group)
    return new_group, True

  def update_jobs_orders_dict(self):
    """
    This method updates the dictionary that holds all the jobs orders of all holes groups.
    It is used only for statistics purposes
    """
    for hole_group in self.holes_groups:
      if hole_group.jobs_order not in self.jobs_orders_dict:
        self.jobs_orders_dict[hole_group.jobs_order] = 'Order ' + str(len(self.jobs_orders_dict)+1)


class HoleGroup():
  """
  An object of this class holds all the holes in the same hole group, and the
  description of the hole.
  """
  def __init__(self, new_coordinates, geom_shape):
    self.centers = set(new_coordinates)  # The (x,y) coordinates of holes in this hole group
    self.jobs = []                # The jobs performed on this hole group by the order they were performed
    self.jobs_order = ''          # A string that holds the order of the jobs
    self.geom_shape = geom_shape  # Geomertric shape of the holes in this hole group
    self.part_name       = None
    self.diameter        = None   # The smallest diameter of the holes
    self.hole_depth      = None
    self.thread_depth    = 0
    self.thread_diameter = 0
    self.thread_pitch    = 0

  def add_job(self, job, drill_job_flag, job_type, tool_type, tool_parameters, job_depth, new_coordinates, job_number):
    """
    This method assigns a job to a hole group ONLY if the same exact job doesn't
    already exists - we check for existance via comparison of job depth, job type,
    tool type, and tool parameters.
    """
    new_job_flag = True              # If stays True, then it is a new job
    job_type = process_job_name(job_type)    # Cosmetics
    tool_type = process_tool_type_name(tool_type) # Cosmetics
    if "ver" in tool_parameters:     # Removing unnecessary field from json: "ver" under tool_parameters
      tool_parameters.pop("ver")

    # Checking if the job already exists
    for existing_job in self.jobs:   # Going over all the existing jobs in that hole group
      # if true, then job already exists
      if (existing_job.job_depth       == job_depth and      # Same job depth
          existing_job.job_type        == job_type  and      # Same job type
          existing_job.tool_type       == tool_type and      # Same tool type
          existing_job.tool_parameters == tool_parameters):  # Same tool parameters
        new_job_flag = False
        break

    if new_job_flag:  # Add the job if its new
      new_job = Job(job, drill_job_flag, job_type, tool_type,
                    tool_parameters, job_depth, new_coordinates, job_number)
      self.jobs.append(new_job)
      self.jobs_order += f"{new_job.job_type} - {new_job.tool_type} | "

  def update_parameters(self, holes_group_info, part_name):
    """
    This method update the parameters of a hole group.
    The update takes place only ONCE - when the group is created.
    """
    # Adding the holes group part name
    self.part_name = part_name
    # Calculating the hole's diameter - taking the MINIMAL radius
    geom_shape = holes_group_info["_geom_ShapePoly"]
    self.diameter = abs(2*min(item["p0"][0] for item in geom_shape))
    # Updating the hole's parameters
    self.hole_depth      = holes_group_info["_geom_depth"]           # Hole's depth
    self.thread_depth    = holes_group_info["_geom_thread_depth"]    # Hole's thread depth
    self.thread_diameter = holes_group_info["_geom_thread_diameter"] # Hole's thread diameter
    self.thread_pitch    = holes_group_info["_geom_thread_pitch"]    # Hole's thread pitch

  def print(self):
    """ This method prints selected fields from that hole group """
    print(f"Part name: {self.part_name}")
    print(f"Number of instances : {len(self.centers)}")
    print(f"Geometry shape: {self.geom_shape}") # Print when checking MACs
    print(f"Holes centers: {self.centers}")      # For debugging
    print(f"Diameter: {self.diameter}")
    print(f"Depth: {round(self.hole_depth, 3)}")
    print(f"{bold_s}{len(self.jobs)} jobs total{bold_e} were performed on this hole group.\nThe order they're being exectued:")
    for i, job in enumerate(self.jobs):
      print(f"{i+1} - {job}")
    print('')


class Job:
  """
  An object of this class holds a job that is done on a hole.
  Each field holds the json's field with the same name.
  """
  def __init__(self, job, drill_job_flag, job_type, tool_type, tool_parameters, job_depth, new_coordinates, job_number):
    self.job_number = job_number            # Job's index in SolidCAM
    self.job_name = job['name']             # Job name as defined by the user
    self.centers = set(new_coordinates)     # The (x,y) coordinates of holes that are being worked by this job
    self.job_type = job_type                # Technology used (e.g, 2_5D_Drilling)
    self.tool_type = tool_type              # Tool being used (e.g, End Mill)
    self.tool_parameters = tool_parameters  # Tool parameters
    self.job_depth = job_depth
    self.home_number = job['home_number']
    self.parallel_home_numbers = job['home_vParallelHomeNumbers']

    # Only assign drill-related attributes if drill_job_flag is True
    drill = job.get("drill", {}) if drill_job_flag else {}
    cycle = drill.get("cycle", {})
    self.drill_cycle_type = cycle.get("drill_type")
    self.drill_gcode_name = cycle.get("gcode_name")
    self.drill_params =     cycle.get("params")
    self.cycle_is_using =         drill.get("cycle_isUsing")
    self.depth_diameter_value =   drill.get("depth_diameter_value")
    self.depth_is_cutter_tip =    drill.get("depth_is_cutter_tip")
    self.depth_is_full_diameter = drill.get("depth_is_full_diameter")
    self.depth_is_tool_Diameter = drill.get("depth_is_tool_Diameter")

  def __repr__(self):
    # return 'Job type & Tool type: {}, Job name: {}'.format(f"{self.job_type} - {self.tool_type}", self.job_name)
    return 'Job type: {}, Tool type: {}, Job name and number: {} ({})'.format(self.job_type, self.tool_type, self.job_name, self.job_number)

"""## Processing - assigning jobs to relevant holes groups"""

# @title Process drilling jobs

def process_drilling_jobs(job, job_number, part_name):
  """
  This function processes ONLY the jobs that involve drilling:
  1. It creates topologies.
  2. Assigns hole group to the relevant topologies.
  3. Assigns jobs to the relevant hole group.

  Args:
    job:       The operation (job) that is done on the stock material.
    part_name: The name of the part.
  """
  # Checking if the job is not pre-drilling for creating pockets
  if "recognized_holes_groups" in job['geometry']:
    # Calculating the Rotation Matrix and Translation Vector for each job
    rotation_mat, translation_vec = rotation_translation(job['home_matrix'])

    # Loops on the holes groups in each job
    for holes_group_info in job['geometry']["recognized_holes_groups"]:
      holes_positions = holes_group_info['_tech_positions']

      # Defining a set with the holes centers - each hole center is (x,y,z) coordinates
      if holes_group_info["_positions_format"] == "VFrmt_P3Str_P3End_V3Dir":
        # For this position format, take only the first 3 values (out of 9) of each point
        new_coordinates = [holes_positions[i:i+3] for i in range(0, len(holes_positions), 9)]

      elif holes_group_info["_positions_format"] == "VFrmt_XY":
        # For XY position format, take (x,y) values and set 'z' to 0.
        new_coordinates = {(round(holes_positions[i], 3),
                          round(holes_positions[i+1], 3),
                          round(holes_group_info["_geom_upper_level"], 3)) for i in range(0, len(holes_positions), 2)}
      else:
        print("Haven't encounterd this format yet. Need to check it out")


      # Transforming the points to the CAD coordinate system origin
      new_coordinates = transform_points(new_coordinates, rotation_mat, translation_vec)

      # Checking if the topology type is a valid string, and Cosmetics
      topology = topology_sort(holes_group_info["_topology_type"])
      # topology_mask = holes_group_info[""]
      if topology == False:
        break
      # if it's the first time encountering that topology, add it
      if topology not in topologies_dict:
        topologies_dict[topology] = Topology(topology)

      # Saving the hole's group geometry shape
      geom_shape = holes_group_info["_geom_ShapePoly"]
      # If it's the first time encountering that geometry shape & holes, add it
      holes_group, new_group_flag = topologies_dict[topology].add_hole_group(job, new_coordinates, geom_shape)

      # Adding the job to hole group
      holes_group.add_job(job, True, job['type'], job['tool']['tool_type'], job['tool'], job['job_depth'], new_coordinates, job_number)

      # If it's a new hole group, we initialize its parameters
      if new_group_flag:
        holes_group.update_parameters(holes_group_info, part_name)

# # @title Process drilling jobs

# def process_drilling_jobs(job, job_number, part_name):
#   """
#   This function processes ONLY the jobs that involve drilling:
#   1. It creates topologies.
#   2. Assigns hole group to the relevant topologies.
#   3. Assigns jobs to the relevant hole group.

#   Args:
#     job:       The operation (job) that is done on the stock material.
#     part_name: The name of the part.
#   """
#   # Checking if the job is not pre-drilling for creating pockets
#   if "recognized_holes_groups" in job['geometry']:
#     # Calculating the Rotation Matrix and Translation Vector for each job
#     rotation_mat, translation_vec = rotation_translation(job['home_matrix'])

#     # Loops on the holes groups in each job
#     for holes_group_info in job['geometry']["recognized_holes_groups"]:
#       # Defining a set with the holes centers - each hole center is (x,y,z=0) coordinates
#       holes_positions = holes_group_info['_geom_positions']
#       new_coordinates = {(round(holes_positions[i], 3),
#                           round(holes_positions[i+1], 3),
#                           0) for i in range(0, len(holes_positions), 2)}
#       # Transforming the points to the CAD coordinate system origin
#       new_coordinates = transform_points(new_coordinates, rotation_mat, translation_vec)

#       # Checking if the topology type is a valid string, and Cosmetics
#       topology = topology_sort(holes_group_info["_topology_type"])
#       topology_mask = holes_group_info[""]
#       if topology == False:
#         break
#       # if it's the first time encountering that topology, add it
#       if topology not in topologies_dict:
#         topologies_dict[topology] = Topology(topology)

#       # Saving the hole's group geometry shape
#       geom_shape = holes_group_info["_geom_ShapePoly"]
#       # If it's the first time encountering that geometry shape & holes, add it
#       holes_group, new_group_flag = topologies_dict[topology].add_hole_group(job, new_coordinates, geom_shape)

#       # Adding the job to hole group
#       holes_group.add_job(job, True, job['type'], job['tool']['tool_type'], job['tool'], job['job_depth'], new_coordinates, job_number)

#       # If it's a new hole group, we initialize its parameters
#       if new_group_flag:
#         holes_group.update_parameters(holes_group_info, part_name)

# @title Process non-drilling jobs

def process_non_drilling_jobs(job, job_number):
  """
  This function processes all the jobs that DO NOT involve drilling.
  Important to note - jobs are assigned to the relevant hole group ONLY if that
  hole group already exists. I check whether a group exists by a bit intricate comparing
  of coordinates.
  """
  # Checking if vals field exists
  if "vals" in job['geometry']:
    vals = job['geometry']['vals']

    # Calculating the Rotation Matrix and Translation Vector for each job
    rotation_mat, translation_vec = rotation_translation(job['home_matrix'])

    # Defining a set with the holes centers - each hole center is (x,y,z=0) coordinates
    new_coordinates = {(round(vals[i], 3),
                    round(vals[i+1], 3),
                    0) for i in range(0, len(vals), 3)}
    # Transforming the points to the CAD coordinate system origin
    new_coordinates = transform_points(new_coordinates, rotation_mat, translation_vec)

    # Assigning jobs to holes via "vals" field
    for key, topology in topologies_dict.items():  # Going over all the topologies
      for group in topology.holes_groups:          # Going over all the holes groups inside each topology
        for existing_job in group.jobs:            # Going over all the jobs inside each hole group
          for new_center in new_coordinates:       # Going over all holes in the CURRENT job
            # If true, the center in the cuurent job belongs to an existing hole group, then we try to assign the current job to this hole group.
            # If false, this job doesn't work on any existing hole group, so we don't try to assign it
            if not compare_coordinates(new_center, existing_job.centers, group.hole_depth,
                              job["home_number"], existing_job.parallel_home_numbers):
              # Adding the job only if it's the first time encountered
              group.add_job(job, False, job['type'], job['tool']['tool_type'], job["tool"], job['job_depth'], new_coordinates, job_number)

# @title Main
"""
The main loop goes over all the parts, and processes each part.
A part can be processed by either two functions:
  1. process_drilling_jobs: as its name suggests, it processes only drilling jobs -
     jobs that contain "drill" field in their JSON.
     *Note that if a job contains "drill" field, but 'recognized_holes_groups' field is missing,
     this job is probably a pre-drilling for a pocket.

  2. process_non_drilling_jobs: as its name suggests, it processes jobs that
     doesn't involve drilling.
     Such jobs ('Profile' for example) does NOT contain any hole information. They contain
     only the values of the holes they are working on - 'vals' field, under 'geometry' field.
"""


### Global Variables

# Used in order to compare between coordinates of centers of holes.
# It is required because the field "_tech_positions" values should be equal to the field 'vals'
# values, but they are only approximately close.
tolerance = 0.111

topologies_dict = {} # Holds all the different topologies


### Processing loop ###

# Going over on all the parts, and process them
for part_name in os.listdir(dir_path):
    # Processing only files that ends with .json
    if part_name.endswith('.json'):
        file_path = os.path.join(dir_path, part_name)

        # Read the JSON file
        data = read_json(file_path)

        # Checking if the data is in inch or mm
        is_inch = 1 if (data["event_data"]["part"]["is_inch"]==True) else 0

        # Going over all jobs in the part
        for job_number, job in enumerate(data["event_data"]["jobs"]):
          # # If the data is in inch, converting it to mm
          # if is_inch:
          #   job = convert_json_units(job)

          # True if the job contains "drill" field (meaning its a drilling job)
          if "drill" in job or job["type"]=="NC_JOB_MW_DRILL_5X":
            # Checking if the job is not pre-drilling for creating pockets
            if "recognized_holes_groups" in job['geometry']:
              process_drilling_jobs(job, job_number+1, part_name)
          else:
            process_non_drilling_jobs(job, job_number+1)

"""# Data Analysis and Statistics"""

### Printing Stats

"""
Most of the stats that are printed here are used for DEBUGGING purposes.
In order to change the stats that are being printed, head to the method 'print' under
'HoleGroup' class.
"""

bold_s = '\033[1m' # Start to write in bold
bold_e = '\033[0m' # End to write in bold

# For each topology, updates the dictionary that holds all the jobs orders of all holes groups
# It is used only for statistics purposes
for _, topology in topologies_dict.items():
  topology.update_jobs_orders_dict()

diameters = []
depths = []


# Print the updated holes_dict
for _ , topology in topologies_dict.items():
  print(f"{bold_s}Topology: {topology.topology}{bold_e}")
  print(f"Total number of hole groups: {len(topology.holes_groups)}")
  total_instances = 0
  for hole_group in topology.holes_groups:
    total_instances += len(hole_group.centers)
  print(f"Total number of instances: {total_instances}\n")


  for group in topology.holes_groups:
    group.print()
    diameters += [group.diameter] * len(group.centers)
    depths += [group.hole_depth] * len(group.centers)
  print("______________________________________________________\n")

# @title Printing Bar Plots

def bar_plots(topologies_dict):
    """
    This function creates bar plots for each topology.
    The 'x' axis represents the order of the jobs being performed on that topology.
    The 'y' axis represents the number of holes in each hole group in that topology.

    Args:
      topologies_dict: Dictionary containing topologies, each containing hole groups with centers and jobs_order.
    """
    # Iterating over each topology in the dictionary
    for topology_name, topology in topologies_dict.items():
      # Dictionary to hold the frequency of centers for each job order
      jobs_order_dict = {}

      # Printing the legend (each jobs order number meaning)
      for jobs_order, val in topology.jobs_orders_dict.items():
        print(f"{bold_s}{val}{bold_e}: {jobs_order}")

      # Iterate over each hole group in the topology
      for group in topology.holes_groups:
        # Extracting the job order and the number of centers
        jobs_order = topology.jobs_orders_dict[group.jobs_order]
        num_centers = len(group.centers)

        # If the job order exists in the dictionary, update the count
        if jobs_order in jobs_order_dict:
          jobs_order_dict[jobs_order] += num_centers
        else:
          jobs_order_dict[jobs_order] = num_centers

      # Plotting the histogram for the current topology
      plt.figure(figsize=(10, 6))
      plt.bar(jobs_order_dict.keys(), jobs_order_dict.values())
      plt.xlabel('Job Order')
      plt.ylabel('Number of Holes')
      plt.title(f'{topology_name} - Order of Jobs')
      plt.tight_layout()  # Adjust layout to ensure everything fits
      plt.show()

      print("\n\n___________________________________________________\n\n")

# Call the function to plot the histograms
bar_plots(topologies_dict)

# @title Exporting to Execl - single file

# """
# In this cell I'm trying to make a SINGLE excel file for ALL topologies.
# For the meanwhile, I'm trying the approach of making a unique excel file for
# each topology.
# """

# import pandas as pd

# # Function to create a DataFrame from topologies_dict
# def create_topology_dataframe(topologies_dict):
#     # Create a dictionary to hold the data for each topology
#     data = {}

#     # Iterate over each topology and its hole groups
#     for topology_name, topology in topologies_dict.items():
#         # Dictionary to hold jobs_order and total count for each hole group
#         jobs_order_dict = {}

#         # Iterate through the hole groups in the topology
#         for group in topology.holes_groups:
#             jobs_order = group.jobs_order
#             num_elements = len(group.centers)

#             # If the jobs_order already exists, aggregate the number of elements
#             if jobs_order in jobs_order_dict:
#                 jobs_order_dict[jobs_order] += num_elements
#             else:
#                 jobs_order_dict[jobs_order] = num_elements

#         # Prepare the data for the DataFrame by alternating rows for jobs_order and element count
#         rows = []
#         for jobs_order, count in jobs_order_dict.items():
#             rows.append(jobs_order)  # First subrow: jobs_order
#             rows.append(count)       # Second subrow: number of elements

#         # Add the data for the current topology to the dictionary
#         data[topology_name] = rows

#     # Find the maximum number of rows across all topologies (for consistent row count)
#     max_rows = max(len(rows) for rows in data.values())

#     # Ensure that all topologies have the same number of rows by filling with empty values
#     for topology_name, rows in data.items():
#         while len(rows) < max_rows:
#             rows.append('')  # Fill with empty string

#     # Create the DataFrame
#     df = pd.DataFrame(data)

#     return df

# # Call the function to create the DataFrame
# topologies_df = create_topology_dataframe(topologies_dict)

# topologies_df.index = ["Jobs & Tools" if i % 2 == 0 else "Instances" for i in range(len(topologies_df))]

# # Display the DataFrame
# topologies_df

# # # Export the dataframe to Excel
# # topologies_df.to_excel("topologies_dataframe.xlsx", index=True)

import pandas as pd

# Dictionary holding the DataFrames for each topology
topology_dataframes = {}

# Hole's group fields we want to include in the database
hole_group_fields = ['job_order', 'diameter', 'hole_depth', 'thread_depth',
                    'thread_diameter', 'thread_pitch']
# Job's fields we want to include in the database
job_fields = ['job_type', 'tool_type', 'job_depth', 'drill_cycle_type',
              'drill_gcode_name', 'drill_params','cycle_is_using',
              'depth_diameter_value', 'depth_is_cutter_tip',
              'depth_is_full_diameter', 'depth_is_tool_Diameter']


for topology_name, topology in topologies_dict.items():
    # List to hold all data for the current topology's DataFrame
    df_data = []

    for hole_group in topology.holes_groups:
      pass
    # num_rows = len()

    for hole_group in topology.holes_groups:
        # General data for each HoleGroup
        df_data.append({
            'job_order': hole_group.jobs_order,
            'diameter': hole_group.diameter,
            'hole_depth': hole_group.hole_depth,
            'thread_depth': hole_group.thread_depth,
            'thread_diameter': hole_group.thread_diameter,
            'thread_pitch': hole_group.thread_pitch,
            # Extend with None to align with job columns
            'job_type': None, 'tool_type': None, 'job_depth': None,
            'drill_cycle_type': None, 'drill_gcode_name': None, 'drill_params': None,
            'cycle_is_using': None, 'depth_diameter_value': None, 'depth_is_cutter_tip': None,
            'depth_is_full_diameter': None, 'depth_is_tool_Diameter': None
        })

        # Add a blank row after general data
        df_data.append({key: None for key in df_data[-1].keys()})

        # Add data for each job in the hole group
        for job in hole_group.jobs:
            df_data.append({
                'job_order': None,
                'diameter': None,
                'hole_depth': None,
                'thread_depth': None,
                'thread_diameter': None,
                'thread_pitch': None,
                'job_type': job.job_type,
                'tool_type': job.tool_type,
                'job_depth': job.job_depth,
                'drill_cycle_type': job.drill_cycle_type,
                'drill_gcode_name': job.drill_gcode_name,
                'drill_params': job.drill_params,
                'cycle_is_using': job.cycle_is_using,
                'depth_diameter_value': job.depth_diameter_value,
                'depth_is_cutter_tip': job.depth_is_cutter_tip,
                'depth_is_full_diameter': job.depth_is_full_diameter,
                'depth_is_tool_Diameter': job.depth_is_tool_Diameter
            })

            # Add a blank row after each job for clarity
            df_data.append({key: None for key in df_data[-1].keys()})

    # Convert list of dictionaries to a DataFrame
    topology_df = pd.DataFrame(df_data).transpose()

    # Store the DataFrame in the dictionary with the topology name as the key
    topology_dataframes[topology_name] = topology_df

# Display each DataFrame to the user
for name, df in topology_dataframes.items():
    print(f"\nDataFrame for Topology: {name}")
    display(df)



# @title Remove empty rows from the end of a DataFrame in Pandas

"""
Explanation:
1 - dropna(how="all"): Removes rows where all values are NaN.
2 - index[-1]: Finds the index of the last non-empty row.
3 - iloc[:last_valid_index + 1]: Slices the DataFrame to include rows only up to the last non-empty row.
"""

import pandas as pd
import numpy as np

# Create a 5x5 DataFrame with some empty rows
data = {
    "A": [1, 2, 3, np.nan, np.nan],
    "B": [4, 5, 6, np.nan, np.nan],
    "C": [7, 8, 9, np.nan, np.nan],
    "D": [10, 11, 12, np.nan, np.nan],
    "E": [13, 14, 15, np.nan, np.nan]
}

df = pd.DataFrame(data)

print("Original DataFrame:")
print(df)

# Identify the last row index with any non-NaN value
last_valid_index = df.dropna(how="all").index[-1] if not df.dropna(how="all").empty else -1

# Slice the DataFrame to include only rows up to the last valid index
df_trimmed = df.iloc[:last_valid_index + 1]

print("\nTrimmed DataFrame:")
print(df_trimmed)



# @title Just testing stuff. Delete later

import json

# Load the JSON file
with open("/content/5X DRILL.PRT.ML.json", "r") as file:
    data = json.load(file)

# Initialize a counter for the total numbers
total_numbers = 0

# Navigate through the JSON structure
if "event_data" in data and "jobs" in data["event_data"]:
    for job in data["event_data"]["jobs"]:
        if "geometry" in job and "recognized_holes_groups" in job["geometry"]:
            for group in job["geometry"]["recognized_holes_groups"]:
                if "_tech_positions" in group:
                    total_numbers += len(group["_tech_positions"])

# Output the result
print(f"Total numbers in '_tech_positions': {total_numbers}")
print(f"Total number of holes: {total_numbers/9}")

# @title Just testing stuff. Delete later

import json

def retain_tech_positions(data):
    if isinstance(data, dict):  # If the data is a dictionary
        if "_tech_positions" in data:  # Retain only "_tech_positions"
            return {"_tech_positions": data["_tech_positions"]}
        # Recursively process child dictionaries
        return {key: retain_tech_positions(value) for key, value in data.items() if isinstance(value, (dict, list))}
    elif isinstance(data, list):  # If the data is a list
        # Recursively process each item in the list
        return [retain_tech_positions(item) for item in data]
    return None  # Remove other data types

# Load the JSON file
with open("/content/5X DRILL.PRT.ML.json", "r") as file:
    data = json.load(file)

# Retain only "_tech_positions" fields
filtered_data = retain_tech_positions(data)

# Save the filtered JSON to a new file
with open("filtered_file.json", "w") as file:
    json.dump(filtered_data, file, indent=4)

print("Filtered JSON saved to 'filtered_file.json'.")









point_drill_1 = {(25.0, 23.98049596091036, 0)}
home_matrix_drill_1 = [
    0.0,    1.0,     0.0,        25.0,
    0.0,    0.0,    -1.0,        50.0,
    -1.0,    0.0,    -0.0,      -25.0,
    0.0,    0.0,    0.0,         1.0
]
rotation_mat_drill_1, translation_vec_drill_1 = rotation_translation(home_matrix_drill_1)
new_coordinates_drill_1 = transform_points(point_drill_1, rotation_mat_drill_1, translation_vec_drill_1)
# print("new_coordinates_drill_1 are: ", new_coordinates_drill_1)

point_drill_2 = {(24.999999999999996, 10.717985952179987, 0)}
home_matrix_drill_2 = [
    1.0,    0.0,    -0.0,       25.0,
    0.0,    0.0,    1.0,        0.0,
    0.0,    -1.0,    0.0,      -25.0,
    0.0,    0.0,    0.0,        1.0
]
rotation_mat_drill_2, translation_vec_drill_2 = rotation_translation(home_matrix_drill_2)
new_coordinates_drill_2 = transform_points(point_drill_2, rotation_mat_drill_2, translation_vec_drill_2)
# print("new_coordinates_drill_2 are: ", new_coordinates_drill_2)




#   point_drill_3_a = [
#     25.0,    0.0,    26.01950403908964,
#     -25.0,    0.0,    26.01950403908964,
#     1.0,    0.0,    0.0,

#     -3.552713678800501e-15,    25.0,    10.717985952179987,
#     -3.552713678800501e-15,    -25.0,    10.717985952179987,
#     0.0,    1.0,    0.0
# ]
point_drill_3_a = {(25.0,    0.0,    26.01950403908964), (-25.0,    0.0,    26.01950403908964)}
point_drill_3_b = {(-3.552713678800501e-15,    25.0,    10.717985952179987), (-3.552713678800501e-15,    -25.0,    10.717985952179987)}
home_matrix_drill_3 = [
    1.0,    0.0,    -0.0,        0.0,
    -0.0,    1.0,    0.0,        0.0,
    0.0,    0.0,    1.0,         0.0,
    0.0,    0.0,    0.0,         1.0
]
rotation_mat_drill_3, translation_vec_drill_3 = rotation_translation(home_matrix_drill_3)
new_coordinates_drill_3_a = transform_points(point_drill_3_a, rotation_mat_drill_3, translation_vec_drill_3)
new_coordinates_drill_3_b = transform_points(point_drill_3_b, rotation_mat_drill_3, translation_vec_drill_3)

print("new_coordinates_drill_1 are: ", new_coordinates_drill_1)
print("new_coordinates_drill_3_a are: ", new_coordinates_drill_3_a)
print("\n")
print("new_coordinates_drill_2 are: ", new_coordinates_drill_2)
print("new_coordinates_drill__3_b are: ", new_coordinates_drill_3_b)

point_drill_1 = {(-14.783166885375977, 0.0, 0)}
home_matrix_drill_1 = [
    1.0, 0.0, 0.0, 0.0,
    0.0, -1.0, 0.0, 0.0,
    0.0, -0.0, -1.0, 0.0,
    0.0, 0.0, 0.0, 1.0
]
rotation_mat_drill_1, translation_vec_drill_1 = rotation_translation(home_matrix_drill_1)
new_coordinates_drill_1 = transform_points(point_drill_1, rotation_mat_drill_1, translation_vec_drill_1)


point_drill_3_a = {(0.0, 15.0, -39.78316686295321), (0.0, -15.0, -39.78316686295321)}
home_matrix_drill_3 = [
   -0.0, 1.0, 0.0, 0.0,
   0.0, -0.0, 1.0, -25.0,
   1.0, 0.0, 0.0, -25.0,
   0.0, 0.0, 0.0, 1.0
]
rotation_mat_drill_3, translation_vec_drill_3 = rotation_translation(home_matrix_drill_3)
new_coordinates_drill_3_a = transform_points(point_drill_3_a, rotation_mat_drill_3, translation_vec_drill_3)

print("new_coordinates_drill_1 are: ", new_coordinates_drill_1)
print("new_coordinates_drill_3_a are: ", new_coordinates_drill_3_a)

import numpy as np

def is_point_on_line(p0, p1, p, epsilon=1e-6):
    """
    Check if point p is on the infinite line passing through p0 and p1 within a distance epsilon.

    Args:
        p0 (array-like): The starting point of the line (x0, y0, z0).
        p1 (array-like): The second point defining the line (x1, y1, z1).
        p (array-like): The point to check (x, y, z).
        epsilon (float): The maximum allowed distance from the line.

    Returns:
        bool: True if p is on the line within distance epsilon, otherwise False.
    """
    # Convert inputs to numpy arrays
    p0 = np.array(p0)
    p1 = np.array(p1)
    p = np.array(p)

    # Compute vectors
    line_vec = p1 - p0
    point_vec = p - p0

    # Compute the cross product and its magnitude
    cross_product = np.cross(point_vec, line_vec)
    distance = np.linalg.norm(cross_product) / np.linalg.norm(line_vec)

    # Check if the distance is within epsilon
    return distance <= epsilon

def is_point_between(p0, p1, p):
    """
    Check if point p lies between points p0 and p1 on the line segment.

    Args:
        p0 (array-like): The starting point of the line segment (x0, y0, z0).
        p1 (array-like): The end point of the line segment (x1, y1, z1).
        p (array-like): The point to check (x, y, z).

    Returns:
        bool: True if p lies between p0 and p1, otherwise False.
    """
    # Convert inputs to numpy arrays
    p0 = np.array(p0)
    p1 = np.array(p1)
    p = np.array(p)

    # Check the parameter t for each component (x, y, z)
    t_x = (p[0] - p0[0]) / (p1[0] - p0[0]) if (p1[0] - p0[0]) != 0 else 0
    t_y = (p[1] - p0[1]) / (p1[1] - p0[1]) if (p1[1] - p0[1]) != 0 else 0
    t_z = (p[2] - p0[2]) / (p1[2] - p0[2]) if (p1[2] - p0[2]) != 0 else 0

    # Check if t values are consistent and within [0, 1]
    return (0 <= t_x <= 1 or p0[0] == p1[0]) and \
           (0 <= t_y <= 1 or p0[1] == p1[1]) and \
           (0 <= t_z <= 1 or p0[2] == p1[2])

# Example usage
# p0 = [1, 1, 1]
# p1 = [4, 4, 4]
# p = [2.5, 2.5, 2.5]

# p0 = [0.0, 15.0, -39.78316686295321]
# p1 = [-25.0,    0.0,    26.01950403908964]
# p = [-14.783166885375977, 0.0, 0]

p0 = [-14.783, 0.0, 40.0]
p1 = [-14.783, 0.0, 10.0]
p = [-14.783, 0.0, 0.0]

print(is_point_on_line(p0, p1, p, epsilon=1e-6))  # Should return True
print(is_point_between(p0, p1, p))  # Should return True